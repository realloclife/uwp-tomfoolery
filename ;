#include <iostream>
#include <tuple>
#include <thread>
#include <string>
#include <string_view>
#include <format>
#include <Windows.h>

#include "console.hpp"
#include "execution.hpp"

using namespace std::literals;

struct wnd_state {
	static constexpr auto menu_exit = WM_APP + 101;
	static constexpr auto menu_execute = WM_APP + 103;
	static constexpr auto menu_text_box = WM_APP + 104;
	static constexpr auto menu_clear = WM_APP + 105;
	static constexpr auto menu_minimize = WM_APP + 109;

	HWND main_window{};
	HMENU menu{};
	HMENU menu_popup_file{};
	HMODULE instance{};
	HWND text_box{};

	uintptr_t lua_state{};
} window_state{};

auto window_proc(HWND window, UINT message, WPARAM w, LPARAM l) -> LRESULT CALLBACK {
	switch (message) {
	case WM_COMMAND:
		switch (w) {
		case wnd_state::menu_exit:
			SendMessage(window, WM_CLOSE, 0, 0);
			break;
		case wnd_state::menu_minimize:
			ShowWindow(window, SW_MINIMIZE);
			break;
		case wnd_state::menu_clear:
			SetDlgItemText(window, wnd_state::menu_text_box, "");
			break;
		case wnd_state::menu_execute:
		{
			auto text_box = GetDlgItem(window, wnd_state::menu_text_box);
			auto length = GetWindowTextLength(text_box);
			auto buffer = new char[length];
			GetDlgItemText(window, wnd_state::menu_text_box, buffer, length);
			std::string script{ std::move(buffer) };
			exec::execute_script(window_state.lua_state, script);
			break;
		}
		}
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(window, message, w, l);
	}
}

auto register_window_class(std::string_view class_name) noexcept -> void {
	WNDCLASSEX wc{};
	wc.hInstance = GetModuleHandle(nullptr);
	wc.lpszClassName = class_name.data();
	wc.lpfnWndProc = reinterpret_cast<WNDPROC>(window_proc);
	wc.style = CS_DBLCLKS;
	wc.cbSize = sizeof wc;
	wc.hIcon = LoadIcon(nullptr, IDI_APPLICATION);
	wc.hIconSm = LoadIcon(nullptr, IDI_APPLICATION);
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wc.lpszMenuName = "STIGMA_MENU";
	wc.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_BACKGROUND);
	RegisterClassEx(&wc);
}

auto create_window_menu() noexcept -> HMENU {
	auto menu = CreateMenu();
	window_state.menu_popup_file = CreatePopupMenu();
	AppendMenu(window_state.menu_popup_file, MF_STRING, wnd_state::menu_minimize, "Minimize");
	AppendMenu(window_state.menu_popup_file, MF_STRING, wnd_state::menu_exit, "Exit");
	AppendMenu(menu, MF_STRING, reinterpret_cast<UINT_PTR>(window_state.menu_popup_file), "File");
	return menu;
}

auto create_ui() {
	window_state.instance = GetModuleHandle(nullptr);
	window_state.menu = create_window_menu();
	register_window_class("DLLWindowClass");
	window_state.main_window = CreateWindowEx(WS_EX_TOPMOST, "DLLWindowClass", "STIGMA_V2", WS_EX_PALETTEWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 439, 486, nullptr, window_state.menu, window_state.instance, nullptr);
	CreateWindow("BUTTON", "EXE", WS_CHILD | WS_VISIBLE, 2, 411, 308, 361, window_state.main_window, reinterpret_cast<HMENU>(wnd_state::menu_execute), window_state.instance, nullptr);
	CreateWindow("BUTTON", "CLEAR", WS_CHILD | WS_VISIBLE, 308, 411, 12, 361, window_state.main_window, reinterpret_cast<HMENU>(wnd_state::menu_execute), window_state.instance, nullptr);
	window_state.text_box = CreateWindowEx(WS_EX_CLIENTEDGE, "EDIT", "", WS_CHILD | WS_VISIBLE | ES_MULTILINE | WS_BORDER | WS_VSCROLL, 2, 12, 437, 302, window_state.main_window, reinterpret_cast<HMENU>(wnd_state::menu_text_box), window_state.instance, nullptr);
	SendMessage(window_state.text_box, EM_SETLIMITTEXT, 0x7FFFFFFE, 0);
}

auto thread_main(console::handle_tuple context, HMODULE module) noexcept -> void {
	console::set_title("uwp-tomfoolery");
	signature::register_signatures();

	auto base = reinterpret_cast<uintptr_t>(GetModuleHandle(nullptr));
	auto scheduler = rbx::get_scheduler();

	uintptr_t waiting_hybrid_scripts_job{};
	for (const auto& job : scheduler.get_jobs()) {
		if (job.get_name() == "WaitingHybridScriptsJob") {
			waiting_hybrid_scripts_job = memory::read<uintptr_t>(job.address);
		}
		console::write(job.get_name());
	}

	std::cout << std::endl;

	auto script_context = memory::read<uintptr_t>(waiting_hybrid_scripts_job + offset::scheduler::whsj_script_context);
	auto lua_state = rbx::get_lua_state(script_context);

	console::write(std::format("Roblox base: {:#X}", base), console::message_type::info);
	console::write(std::format("get_scheduler_singleton: {:#X}", address::get_scheduler_singleton), console::message_type::info);
	console::write(std::format("get_global_state: {:#X}", address::get_global_state), console::message_type::info);
	console::write(std::format("vm_load: {:#X}", address::vm_load), console::message_type::info);
	console::write(std::format("task_defer: {:#X}", address::task_defer), console::message_type::info);
	console::write(std::format("TaskScheduler: {:#X}", scheduler.address), console::message_type::info);
	console::write(std::format("WaitingHybridScriptsJob: {:#X}", waiting_hybrid_scripts_job), console::message_type::info);
	console::write(std::format("ScriptContext: {:#X}", script_context), console::message_type::info);
	console::write(std::format("lua_State: {:#X}", lua_state), console::message_type::info);

	// auto whsj_vmt = memory::read<uintptr_t>(waiting_hybrid_scripts_job);
	// exec::whsj_step_original = memory::vmt_hook(whsj_vmt, 5, reinterpret_cast<uintptr_t>(exec::whsj_step_hook));
	// console::write(std::format("Hooked WaitingHybridScriptsJob.Stepped for script scheduling"), console::message_type::info);

	while (true) {
		std::string input{};
		input.clear();
		std::cout << "> ";
		std::getline(std::cin, input);
		if (input == "exit") {
			console::free(context);
			FreeLibraryAndExitThread(module, 0);
			return;
		}
		exec::execute_script(lua_state, input);
	}
}

auto DllMain(HMODULE module_handle, DWORD call_reason, LPVOID) -> BOOL APIENTRY {
	// DisableThreadLibraryCalls(module_handle);
	if (call_reason != DLL_PROCESS_ATTACH) {
		return TRUE;
	}
	std::thread{ thread_main, console::alloc(), module_handle }.detach();
	return TRUE;
}